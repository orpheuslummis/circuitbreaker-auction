{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":940411529567408621,"abi":{"parameters":[{"name":"old_root","type":{"kind":"field"},"visibility":"private"},{"name":"old_siblings","type":{"kind":"array","length":256,"type":{"kind":"field"}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_bid","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"param_witnesses":{"hashed_bid":[{"start":385,"end":417}],"old_root":[{"start":0,"end":1}],"old_siblings":[{"start":1,"end":257}],"pub_key_x":[{"start":257,"end":289}],"pub_key_y":[{"start":289,"end":321}],"signature":[{"start":321,"end":385}]},"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAA/+2dBXRU5xaF5xIgCSEJwZ3gDpkISdBUKC1V2kK9hZRQaHFSqAJ1F+peSt3d3d3dy3N3930ysx+H/fK61lu9Yb1/9d61vjWz507uv++fO+ecmTXzn41RKnVtKrPhbqqV3eJOntOtROeIbi26jei2onNF54nOF91OdIHo9qILRReJLhbdQXSJ6I6iO4nuLLqL6K6iu4nuLrqH6J6ie4nuLbqP6L6i+4kuFd1f9ADRA0UPEj1Y9BDRQ0UPEz1c9AjRI0WPEj1a9BjRY0WXiU6LLhddIbpSdJXocaKrRdeIrhU9XvQE0RNFTxI9WfQU0XWitxK9tehtRG8reqro7URPE7296B1ETxe9o+idRO8sehfRu4reTfQM0buL3kP0nqJnip4lei/Re4veR/S+ovcTvb/oA0QfKPog0bNFzxFdL/pg0XNFN4ieJ/oQ0fNFLxB9qOjDRC8UvUj0YtFLRC8VvUz0ctErRDeKPlz0StGrRB8h+kjRR4k+WvQxoo8VvVr0GtFrRR8n+njRJ4g+UfRJok8WfYroU0WfJvp00WeIPlP0WaLPFn2O6HNFrxN9nujzRV8g+kLRF4m+WPQloi8VfZnoy0VfIfpK0VeJvlr0eqfzQWkqs7EOZP3Huo/1Hus81nes61jPsY5j/ca6jfUa6zTWZ6zLWI+xDmP9xbqL9RbrLNZXrKtYT7GOYv3Euon1Eusk1kesi0p5m50H1kOsg1j/sO5hvcM6h/UN6xrWM6xjWL+wbmG9wjqF9QnrEtYjrENYf7DuYL3BOoP1BesK1hOsI1g/sG5gvcA6gfVBHW+z88C6gPUA6wDmf+Z95nvmeeZ35nXmc+Zx5m/mbeZr5mnmZ+Zl5mPmYeZf5l3mW+ZZ5lfmVeZT5lHmT+ZN5kvmydnZW+ZF5kPmQeY/5j3mO+Y55jfmNeYz5jHmL+Yt5ivmKeYn5iXmI+Yh5h/mHeYb5hnmF+YV5hPmEeYP5g3mC+aJtfJ6YH5gXmA+YB5g/GfcZ7xnnGd8Z1xnPGccZ/xm3Ga8ZpxmfGZcZjxmHGb8ZdxlvGWcZXxlXGU8ZRxl/GTcZLxknLwmSm22UdZlb8u+2Za24/NYFWXjKisbqssb0hXpOWXltfU1VWWVVfXjatI16aqaqrnlNRUVDTWVNdW19bXVZbXpyoqG9Lyq2op52YPlpDIxnj5LUy3rPYpiO1ZZS3lsFYDHnAA8tg7AY5sAPLYNwGNuAB7zAvCYH4DHdgF4LAjAY/sAPBYG4LEoAI/FAXjsEIDHkgA8dgzAY6cAPHYOwGOXADx2DcBjtwA8dg/AY48APPYMwGOvADz2DsBjnwA89g3AY78APJbG6HFLfBbZP4A5HRCAx4EBeBwUgMfBAXgcEoDHoQF4HBaAx+EBeBwRgMeRAXgcFYDH0QF4HBOAx7EBeCwLwGM6AI/lAXisCMBjZQAeqwLwOC4Aj9UBeKwJwGNtAB7HB+BxQgAeJwbgcVIAHicH4HFKAB7rYv4skh55zA0Q14LrwPXgBnAjuAncDG4Bt4LbwO3gDnAnuAvcDe4B94L7wP3gAfAgeAg8DB4Bj4LHwOPgCfAkeAo8DZ4Bz4LnwPPgBfAieAm8DF4Br4LXwOvgDfAmeAu8Dd4B74L3wPvgA/Ah+Ah8DD4Bn4LPwOfgC/Al+ApsjDLfybXNfg/QKrX51hbkxPz/tHFay7Vi47SJeZy27jziOWZlWdv4r+8yP++8zXfznuMe47y1do9x3vxtodufkmMXZec7P97zKLfj5aU23yLRde4+xzcv7WP1Utk0p+3+By/tnZeCWL1krsPCeI/ZdB0WxXxMO0axmxPOH70XuP1Fbr6KY56vyI3J41J7f4nXxGviNfGaeE28Jl4Tr4nXxGviNfGaeE28Jl4Tr4nXxGviNfGaeE28Jl4Tr4nXxGviNfGaeE28Jl4Tr4nXxGviNfGaeE28Jl4Tr4nXb7dX85InPvPd8/L+D/z5eaOXwni9NH13mt+d57Ht++Z9o01jtot1zPKm32X474PXOQ8cK8c9pz7a5GuA8xXzd9qb5iI3e6x8NxeDt/Bc5H7NXFS4uRgebXoe9+c5/wXyWPzfvc9cyxyHx6Vu786D51LQjL98d+v/ho+1auZvc2SM3EDnIX4vmWtKveSKlxhiSVofsHF9XN/K+eBYOe45k6PN9xU5z/zNi38t6PNsjA7f7Bxky/zmpyTWY5al7Rgd3XnxGihxc8L9U93re5r7rRbP2celWc3s5xaJrnP3O7j56xzvuTZdA13c8evcGH7crvGOm/bjRlk4Bh/Pcfdnugnquunuv+eXnu1/1amZ5/n7RfI3BW5/pxY+587OR53THMuuk+numprlclncdY0/Xz8vBe6W+31tkyfPt/8BXw8+Zsf9uozcODwudYnzx8eKt7CXXPHi6xMfTwYHXAf4/ba1ch75N3qc+H8Pl4n7LfF6YMzzcZ/j5Lj9i91rdKmL6zxnH/fXNLOf29fFfZ83O8Z7rk1x38e6OjeGHzfmfJP24zLucww+nuPur3YT5GMn55ee7X9V0szz/P328jcFbn9JC5/zf4tbHMuukxXumlrj4n7M7yHT/nz9vLR18+LjKfe1xPvqDqnN54Uemnvf719bvEZbOt8UiT9qPz98rND543n4eML36Pqaj82wb4hldy0452QHb5M1lZudNP4IuyA7sYXZEynOmrYTtIvUXoh2kVohZkVKN9Ad9AA9QS/QG/SxEwT9UpkFZfuDAWAgGAQGgyFgKBgGhoMRYCQYBUaDMWCszQOwq7QcVIBKUAXGgWpQA2rBeDABTASTwGQwJTuf9mZma7AN2BZMBduBaWB7sAOYDnYEO4GdwS5gV7AbmAF2B3uAPcFMMAvsBfYG+4B9wX5gf3AAOBAcBGaDOaAeHAzmggYwDxwC5oMF4FBwGFgIFoHFYAlYCpaB5WAFaASHg5VgFTgCHAmOAkeDY8CxYDVYA9aC48Dx4ARwIjgJnAxOAaeC08Dp4AxwJjgLnA3OAeeCdeA8cD64AFwILgIXg0vApeAycDm4AlwJrgJXg/XgGrAhlWlqfh24HtwAbgQ3gZvBLeBWcBu4HdwB7gR3gbvBPeBecB+4HzwAHgQPgYfBI+BR8Bh4HDwBngRPgafBM+BZ8Bx4HrwAXgQvgZfBK+BV8Bp4HbwB3gRvgbfBO+Bd8B54H3wAPgQfgY/BJ+BT8Bn4HHwBvgRfgY3gO+C74Hvg++AH4IfgR+DH4Cfgp+Bn4OfgF+CX4Ffg1+A34Lfgd+D34A/gj+BP4M/gL+Cv4G/g7+Af4J/AXvzWAM4arFkDM2sQZg24rMFVU3PQKNMU1BoMWQMfa5BjDWiswYs1ULEGJSVRpuGnNbCwBhHWgMEaHFgDAVug3xbAtwXmbQF3WyDdFiC3AGcLaJdGmWad9uGfLVpsiwJb0WuL2tqisbYoq30YZouK2qKdtiimLTppizraoolWnVj0tUX17AM0WxTOFl2zRc1s0TBblMsWvbJFpWzRJlsUyRYdsg8omhbNiTJNMq1BpjXHtMaY9kbdGmLam3RrhGlNMO2NljW/tMaX1vTSGl5as0trdDkjyjS4tOaW1tjS3oDamzFrZmmNLK2JpTWwtOaV1rjSmlZaw0prVjk7yjSptA9CrTmlNaa0ppTWkNKaUVojSmtCaQ0orfmkNZ60ppNWVFqzSSsol0WZBpNWFFhjSWsqaQ0lrZmkNZK0JpLWQNKaR1rjSGsaacWSFQ5ro0xzSGsMaU0hrSGkNYO0RpDWBNIaQFrzR2v8aAvMWMNHa/ZojR6tyaM1eFwXZRo7WlNHa+hozRytkaM1cbQGjta80Ro3WtNGa9hozRqtUaM1aVwfpf5ji9zthuz9SdkHe2f1nMbGhkVLG0sbl5TOmTu3dNWCxvmlS1Y2LJ+3cMmqfwHFr2JUIYEAAA==","debug_symbols":"tdzdSmRHGIXhe+ljCf2tqr2rylsJOZBkAgODE6Jn4r3HBHUGpjd2npCzFvaS/nlb5LHap9OXr7/ePX7+ev9wun061X4+3f78dHr44+7+768fHu/+fDzd7q3fnD7d//Zya63nm9Pvn798Ot22l5s/XJptvl6a7y7t5wuXVqVer325df52cT3/cvNyV+r/uiv/fPf8x+/earxe2tr44IFmrLcH2vr+wwPNT9Uu3Zvs+9su+/juCcr7ruNuw92Ou4G7ibtlu5xxV7gL7rCXYC/BXoK9BHsJ9hLspWEvDXtp2EvDXhr20rCXhr007KVhLw176dhLx1469tKxl469dOylYy8de+nYS8deNuxlw1427GXDXjbsZcNeNuxlw1427GXDXnbsZcdeduxlx1527GXHXnbsZcdeduxlx14G9jKwl4G9DOxlYC8DexnYy8BeBvYysJeJvUzsZWIvE3uZ2MvEXib2MrGXib1M7GVhLwt7WdjLwl4W9rKwl4W9LOxlYS8Le6nzWYelw+hQze6saHdWtTsr253V7c4Kd2ctp7Sc0nJKy2HtZe5l72XwZfFl8lXzLUXfUvUtZd9S9y2F31L5LaXfUvstxd9S/S3l31L/LQXgUgEuJeBSAy5F4FIFLmXgUgcuheBSCS6l4Or8t0ktRzW4lINLPbgUhEtFuJSES024FIVLVbiUhUtduBSGS2W4lIZLbbgUh0t1uJSHS324FIhr5xMRWo4acSkSlypxKROXOnEpFJdKcSkVl1pxDT5Mo+UoF5d6cSkYl4pxKRmXmnEpGpeqcSkb1+RzWFqOynEpHZfacSkel+pxKR+X+nEpIJcKci0+wsdn+PQQnxpy1JCjhhw15KghRw05ashRQ44acoqPf2o5ashRQ44actSQo4YcNeSoIYfPDfPBYT85rOXw2WE+PMynh/n4MJ8f5gPEashRQ44achofOtdy1JCjhhw15KghRw05ashRQ44actSQ0/nzClqOGnLUkKOGHDXkqCFHDTlqyFFDjhpy1JCjhhw15KghRw05ashRQ44actSQo4YcNeTs/CkpLUcNOWrIUUOOGnLUkKOGHDXkqCFHDTmDP2Cn5aghRw05ashRQ44aco5gdvX34dovDgcOD+xxbO1tOLbt4rDr8PJdHWN7H866OJw6XDZsBxJ4xbB0OOxZbQfYdcVw4fAAu64Ylg6Dz+oBdl0x7DrcdLjrcOjwoJz5bbjaxeHCYfRtFX1bRcuJlhMtJ1pOtJxoOZk61B/ITctpWk7TcpqW07ScpuU0LadpOU3LaVpO13K6ltO1nK7ldC2nazldy+laTtdyupazaTmblnNETx/9Mt+O6Onj4a7DocOpw4PX8f1/Qb3cXJeGB/R0xfDgdaz9fVjj4jA6bDrsOtx0uOtw6HDqcOHwgJ6uGGo5Q8sZWs7QcoaWM7ScoeUMLWdoOVPLmVrO1HKmljO1nKnlTC1najlTy5laztJylpaz/nU5z89/AQ==","file_map":{"39":{"source":"use dep::std;\nuse dep::ecrecover;\nuse dep::smt_bn254;\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(pub_key: [u8; 64]) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    }\n\n    (pub_key_x, pub_key_y)\n}\n\nfn main(\n    old_root: Field,\n    old_siblings: [Field; smt_bn254::TREE_DEPTH],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_bid: [u8; 32]\n) {\n    let address = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, hashed_bid);\n    //smt_bn254::add(old_root, old_siblings, address, hashed_bid, 0x01);\n}\n\n","path":"/Users/arj/repos/circuitbreaker-auction/circuits/crates/bid_smt_add/src/main.nr"},"40":{"source":"use dep::std;\n\nmod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [\n        131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117\n    ];\n    let pub_key_y = [\n        53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165\n    ];\n    let signature = [\n        57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177\n    ];\n    let hashed_message = [\n        13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102\n    ];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/arj/repos/ecrecover-noir/src/lib.nr"},"41":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(pub_key: [u8; 65]) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    }\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [\n        131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117\n    ];\n    let pub_key_y = [\n        53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165\n    ];\n    let signature = [\n        57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177\n    ];\n    let hashed_message = [\n        13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102\n    ];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/arj/repos/ecrecover-noir/src/secp256k1.nr"},"42":{"source":"use dep::std;\n\npub fn u8_32s_to_u64_16(arr_a: [u8; 32], arr_b: [u8; 32]) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n\n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n        combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n        combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\npub fn u8_32s_to_u64_16_unconstrained(arr_a: [u8; 32], arr_b: [u8; 32]) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n\n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n        combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n        combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117\n    ];\n    let arr_b: [u8; 32] = [\n        53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\npub fn u8_32_to_u8_64(arr_a: [u8; 32], arr_b: [u8; 32]) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\npub fn u8_32_to_u8_64_unconstrained(arr_a: [u8; 32], arr_b: [u8; 32]) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\npub fn u64_4_to_u8_32(array: [u64; 4]) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\npub fn u64_4_to_u8_32_unconstrained(array: [u64; 4]) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n\n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\npub fn u8_to_u160(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\npub fn u8_to_u160_unconstrained(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\npub fn u8_to_eth_address(array: [u8]) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\npub fn u8_to_eth_address_unconstrained(array: [u8]) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193, 255, 211, 207, 238, 45, 158, 92, 214, 118, 67, 248, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\npub fn split_u8_64(arr: [u8; 64]) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    }\n\n    (arr_a, arr_b)\n}\n\nunconstrained\npub fn split_u8_64_unconstrained(arr: [u8; 64]) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    }\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193, 255, 211, 207, 238, 45, 158, 92, 214, 118, 67, 248, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102,\n        193, 255, 211, 207, 238, 45, 158, 92, 214, 118, 67, 248, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/arj/repos/noir-array-helpers/src/lib.nr"}}}
